# שלב ג וד – אינטגרציה, מבטים ותכנות PL/pgSQL


## שער

**שמות מגישים:** אביתר סאסי, ישראל שעשוע  
**המערכת:** מערכת ניהול עובדים  
**היחידה הנבחרת:** אגף משאבי אנוש

---

## תוכן עניינים

1. [מבוא](#מבוא)  
2. [תרשימי DSD ו-ERD](#תרשימי-dsd-ו-erd)  
3. [החלטות אינטגרציה](#החלטות-אינטגרציה)  
4. [פקודות שינוי טבלאות – Integrate.sql](#פקודות-שינוי-טבלאות--integratesql)  
5. [מבטים וניתוח נתונים – Views.sql](#מבטים-וניתוח-נתונים--viewssql)  
6. [גיבוי](#גיבוי)  
7. [סיכום](#סיכום)
8. [שלב ד – תוכניות PL/pgSQL](#שלב-ד--תוכניות-plpgsql)


---

## מבוא

בשלב זה ביצענו אינטגרציה בין המערכת שלנו לבין מערכת נוספת שקיבלנו מזוג אחר. מטרת התהליך הייתה ליצור בסיס נתונים אחוד, תוך שמירה על שלמות הנתונים של שני הצדדים.

התהליך כלל:
- בניית DSD ו־ERD של המערכת שקיבלנו מהגיבוי.
- עיצוב ERD משולב.
- שינוי מבני של בסיס הנתונים באמצעות `ALTER TABLE`.
- טעינת נתונים תוך שמירה על עקביות.
- יצירת שני מבטים וכתיבת שאילתות משמעותיות לכל אחד.

---

## תרשימי DSD ו־ERD


### ERD של המערכת החדשה (שקיבלנו)

![ERD New](images/erd_friend.png)

### DSD של המערכת החדשה (שקיבלנו)

![DSD New](images/dsd_friend.png)

### ERD משולב לאחר אינטגרציה

![ERD Integrated](images/erd_integrated.png)

### DSD לאחר אינטגרציה

![DSD Integrated](images/dsd_integrated.png)


---

## החלטות אינטגרציה

- שמרנו על שמות הטבלאות והעמודות המקוריים כדי לא לפגוע בקוד קיים.
- מיזגנו בין ערכים זהים לפי מזהה `ID`, כאשר במקרי קונפליקט – הנתונים שלנו נשמרו.
- בטבלת `department` הוספנו עמודות `location` ו־`head_of_department`.
- לא יצרנו טבלאות חדשות – נעשה שימוש ב־`ALTER TABLE`.
- הנתונים הוזנו בעזרת `UPDATE` ו־`INSERT` עם התאמות כדי למנוע כפילויות ושגיאות מפתחות זרים.

---

## פקודות שינוי טבלאות – Integrate.sql

בשלב זה ביצענו שינויי סכימה משמעותיים לצורך התאמת בסיס הנתונים למבנה המשולב:

- **שינוי שם טבלה:** הטבלה `entitydepartment` שונתה ל־`department` כדי לאחד שמות בין המערכות.
- **שינוי שם עמודה:** העמודה `name` שונתה ל־`department_name` לטובת קריאות ברורה יותר.
- **הוספת עמודות:** הוספנו עמודה חדשה `head_of_department` שבאה מהמערכת של הזוג השני.
- **הגדרת מפתח ראשי:** וידאנו שהעמודה `department_id` מוגדרת כמפתח ראשי.

בנוסף, נוצרו מספר טבלאות חדשות שנלקחו מהמערכת השנייה:
- טבלת ספקים (`supplier`)
- פרטי מוצרים (`item`)
- קבלות ותשלומים (`receipt`)
- הזמנות רכש (`purchase_order`, `ordered`)
- ניהול מלאי (`stored_in`)
- הקשר בין ספק לפריט (`supplied_by`)

טבלאות אלו מבוססות על ERD חדש שהתקבל מהזוג השני, והשתלבו במערכת שלנו כחלק מהרחבת תשתית הרכש והספקים.


---

## מבטים וניתוח נתונים – `Views.sql`

### View 1 – ניתוח נוכחות עובדים באגף משאבי אנוש

#### תיאור המבט:

המבט `view_attendance_summary` מאגד מידע על נוכחות יומית של עובדים, כולל שם העובד, שם המחלקה, תאריך, וזמני כניסה ויציאה.  
באמצעות מבט זה ניתן לבצע ניתוחים כמו זיהוי עובדים שעובדים שעות חריגות, חישובי שעות חודשיות, או בדיקות איחורים תכופים.

#### SELECT * (10 רשומות ראשונות):

![Attendance View](images/view1_select.png)

---

#### שאילתה 1 – עובדים שעבדו יותר מ־8 שעות ביום

![Query 1 – Long Days](images/view1_query1.png)

**מטרה:**  
לזהות עובדים שביצעו משמרות ארוכות במיוחד.

**למה זה חשוב?**  
שעות עבודה חריגות עשויות להעיד על עומס יתר, עובדים מחויבים במיוחד, או חוסר איזון בתכנון כוח האדם. בעזרת השאילתה הזו ניתן לאתר תבניות של שחיקה או השקעה יוצאת דופן.

---

#### שאילתה 2 – סיכום שעות חודשי לעובדים באפריל 2024

![Query 2 – Monthly Summary](images/view1_query2.png)

**מטרה:**  
לחשב כמה שעות צבר כל עובד במהלך חודש מסוים (במקרה זה: אפריל 2024).

**סיפור רקע:**  
בסוף כל חודש נדרש דו"ח נוכחות לצורכי שכר, פריון עבודה ומעקב אחרי חריגות. שאילתה זו מספקת את סך השעות החודשי לכל עובד, נתון חיוני להנהלה ולמנהלי מחלקות.

---

### View 2 – ריכוז נתוני רכש לפי ספק

#### תיאור המבט:

המבט `view_supplier_orders` מאחד מידע על הזמנות רכש מכל הספקים – כולל מזהה ההזמנה, שם הספק, תאריך, סכום, ופרטי יצירת קשר.  
הוא מאפשר לבצע מעקב אחר ספקים מרכזיים, לזהות ספקים חריגים בפעילותם, ולהפיק דו"חות רכש לצורכי תכנון תקציבי, בקרה והמשכיות עסקית.

#### SELECT * (10 רשומות ראשונות):

![Supplier View](images/view2_select.png)

---

#### שאילתה 1 – ספקים עם הזמנות מעל ממוצע שנת 2024

![Query 1 – Above Average Orders](images/view2_query1.png)

**מטרה:**  
לאתר ספקים שביצעו עסקאות גבוהות מהממוצע הכללי בשנה הנוכחית.

**סיפור רקע:**  
ארגונים מעוניינים לזהות מי הספקים הבולטים מבחינת היקף עסקאות. ספק עם הזמנות שמעל הממוצע יכול להעיד על תלות יתר או דווקא על שותפות אסטרטגית. נתון זה עוזר גם בהחלטות מיקוח וחידוש חוזים.

---

#### שאילתה 2 – סיכום הזמנות לפי ספק

![Query 2 – Summary per Supplier](images/view2_query2.png)

**מטרה:**  
לסכם לכל ספק את מספר ההזמנות, הסכום הכולל והממוצע להזמנה.

**למה זה חשוב?**  
דו"ח זה נותן מבט כולל על ההיקף העסקי של כל ספק מול הארגון. הוא מאפשר להבין מי הם הספקים הפעילים ביותר, כמה כסף הושקע בכל אחד, ולבצע ניתוחים תקציביים ארוכי טווח.

---

## גיבוי

בוצע גיבוי מלא של בסיס הנתונים לאחר ביצוע האינטגרציה והוספת המבטים.  
הגיבוי נשמר בשם `backup3.backup` בפורמט Custom.

---

## סיכום

בשלב זה למדנו לבצע אינטגרציה מלאה בין שני בסיסי נתונים תוך שמירה על עקביות, התאמה לסכמות קיימות, וניצול כלים כמו Views ו־SQL מתקדמות לניתוח נתונים.  
הפקנו דו"חות משמעותיים המספקים תובנות עסקיות וניהוליות, בין אם על התנהגות עובדים ובין אם על ספקים והוצאות.  
התוצאה היא מערכת עשירה בנתונים, עם מבט הוליסטי על תפקוד הארגון משני צדדיו.



# שלב ד – תוכניות PL/pgSQL

## מבוא

בשלב זה התמקדנו בכתיבת פונקציות, פרוצדורות וטריגרים בשפת PL/pgSQL. מטרת השלב הייתה להרחיב את הלוגיקה העסקית של המערכת באמצעות קוד תכנותי, תוך שימוש באלמנטים כמו לולאות, תנאים, CURSORים, רשומות וחריגות.

השלב כלל:
- כתיבת 2 פונקציות
- כתיבת 2 פרוצדורות
- כתיבת 2 טריגרים
- יצירת 2 תוכניות ראשיות (main programs) שמשלבות בין פונקציות לפרוצדורות

---

## פונקציה 1 – דו"ח חודשי לעובד (`get_employee_monthly_report`)

#### תיאור:

מחשבת את מספר ימי העבודה, סך שעות העבודה, והממוצע היומי לעובד בחודש נתון.  
כוללת שימוש ב־`FOR`, רשומות, SUM של זמנים, ו־CASE.

#### קובץ SQL: `function1_stage_d.sql`  
#### הוכחה בהרצה:

![func1](func1.png)

---

## פונקציה 2 – פער מחירים בין ספקים (`report_price_gap_between_suppliers`)

#### תיאור:

מחשבת את הפער באחוזים בין המחיר המינימלי למקסימלי עבור כל פריט שסופק על ידי יותר מספק אחד.  
ממיינת לפי הפער וכוללת LIMIT.

#### קובץ SQL: `function2_stage_d.sql`  
#### הוכחה בהרצה:

![func2](func2.png)

---

## פרוצדורה 1 – הוספת הזמנה אם קיים מלאי (`add_order_if_in_stock`)

#### תיאור:

בודקת האם יש מספיק מלאי לפריט במחלקה.  
אם כן, יוצרת הזמנה ומעדכנת את המלאי. אם לא – נזרקת חריגה.

#### שימושים:
- פקודות DML: `INSERT`, `UPDATE`, `SELECT INTO`  
- תנאים ולולאות  
- חריגות: `RAISE EXCEPTION`

#### קובץ SQL: `prosedure1.sql`  
#### הוכחה בהרצה:

![procedure1](prosedure1.png)

---

## פרוצדורה 2 – עדכון מחירים באחוז מסוים (`update_prices_by_percent`)

#### תיאור:

מעדכנת את כל המחירים בטבלה `supplied_by` לפי אחוז שמועבר כפרמטר.

#### קובץ SQL: `prosedure2.sql`  
#### לפני השינוי:

![before](prosedure2_before.png)

#### אחרי השינוי:

![after](prosedure2_after.png)

---

## טריגר 1 – הגבלת סכום הזמנה (`check_price_limit`)

#### תיאור:

טריגר שמונע הכנסת שורה לטבלת `ordered` אם `amount > 999.99`.  
מופעל לפני `INSERT` ו־`UPDATE`.

#### קובץ SQL: `check_price_limit_trigger.sql`  
#### הוכחה בהרצה:

![trigger1](trigger1.png)

---

## טריגר 2 – בדיקת סדר זמני נוכחות (`validate_attendance_times`)

#### תיאור:

מונע הכנסת שורה ל־`attendance_log` אם שעת היציאה מוקדמת מהכניסה.

#### קובץ SQL: `trigger2.sql`  
#### הוכחה בהרצה:

![trigger2](trigger2.png)

---

## תוכנית ראשית 1 (`main_program1.sql`)

#### תיאור:

מבצעת הזמנה אם יש מלאי (פרוצדורה 1), ולאחר מכן מחזירה דו"ח חודשי לעובד (פונקציה 1) ומדפיסה אותו בלולאה.

#### הוכחה בהרצה:

![main1](mian1.png)

---

## תוכנית ראשית 2 (`main_program2.sql`)

#### תיאור:

מעדכנת את המחירים באחוז מסוים (פרוצדורה 2), ואז מדפיסה את 5 הפריטים עם הפער הכי גבוה (פונקציה 2).

#### הוכחה בהרצה:

![main2](main2.png)

---

## טבלת סיכום דרישות תכנות

| תוכנית               | Cursor | לולאה | תנאי | RAISE | DML | RECORD |
|----------------------|--------|--------|------|--------|-----|--------|
| פונקציה 1            | ✔ (עקיף) | ✔    | ✔    |        |     | ✔      |
| פונקציה 2            |        |        | ✔    |        |     |        |
| פרוצדורה 1           |        |        | ✔    | ✔      | ✔   |        |
| פרוצדורה 2           |        |        |      |        | ✔   |        |
| טריגר 1              |        |        | ✔    | ✔      |     |        |
| טריגר 2              |        |        | ✔    | ✔      |     |        |
| תוכנית ראשית 1       |        | ✔      |      |        | ✔   | ✔      |
| תוכנית ראשית 2       |        | ✔      |      |        | ✔   | ✔      |

---

## גיבוי

בוצע גיבוי מלא של בסיס הנתונים לאחר הוספת כל הפונקציות, הפרוצדורות והטריגרים.  
הקובץ שמור בשם `backup4.backup` בפורמט Custom.

---

## סיכום

שלב ד' אפשר לנו ליישם יכולות לוגיקה מורכבות במערכת הנתונים, להפעיל בדיקות בזמן אמת על נתונים נכנסים, לבצע חישובים עסקיים, ולשלב תהליכים מבוקרים היטב באמצעות קוד תכנותי בתוך מסד הנתונים.
